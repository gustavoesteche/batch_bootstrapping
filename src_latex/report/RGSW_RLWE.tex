\section{RLWE e RGSW} 

Nesta seção os parâmetros para os esquemas serão apresentados tais como descritos em \cite{lw23I} com 
os detalhes específicos utilizados na implementação. 

\subsection{LWE}
Uma breve introdução ao problema Learning With Errors(LWE) a base da segurança dos esquemas utilizados:

\begin{definition}
Considere inteiros $n, q \in \mathbb{N}^*$ e um parâmetro real $\sigma > 0$. Seja $\mathbf{s} \in \mathbb{Z}_q^n$ um vetor secreto fixo. A distribuição $\mathcal{A}_{\mathbf{s}, \chi_\sigma}$ é definida pelo seguinte procedimento:

\begin{itemize}
    \item amostrar $\mathbf{a} \leftarrow \mathbb{Z}_q^n$ uniformemente;
    \item amostrar o erro $e \leftarrow \chi_\sigma$, onde $\chi_\sigma$ é uma distribuição sub-Gaussiana centrada com parâmetro $\sigma$;
    \item computar $b := \langle \mathbf{a}, \mathbf{s} \rangle + e \mod q$;
    \item devolver o par $(\mathbf{a}, b)$.
\end{itemize}
\end{definition}

\begin{definition}
(\textbf{LWE}) Dado um vetor secreto $\mathbf{s} \in \mathbb{Z}_q^n$, o problema \emph{Learning With Errors} (LWE) com parâmetros 
$(n, q, \sigma)$ consiste em, dado acesso a um número polinomial de amostras independentes extraídas da distribuição 
$\mathcal{A}_{\mathbf{s}, \chi_\sigma}$, recuperar o vetor $\mathbf{s}$.

Mais precisamente, o problema decisório do LWE consiste em distinguir, com vantagem não negligenciável, entre amostras da distribuição uniforme $\mathcal{U}(\mathbb{Z}_q^n \times \mathbb{Z}_q)$ 
e amostras da distribuição $\mathcal{A}_{\mathbf{s}, \chi_\sigma}$. É sabido que as duas versão são equivalentes (uma reduz para outra em tempo polinomial).
\end{definition}

Ainda acredita-se que este problema é díficil \cite{BrakerskiEtAl2013}, portanto faz sentido basear esquemas nisso. Porém, provas
e discussões sobre sua dificuldade e definições de parâmetros se estendem juntamente a padronização do NIST (por exemplo \cite{Balbas2021}). 

\subsection{Funções Auxiliares}

Para amostrar o ruído utilizado nos esquemas propostos utiliza-se uma distribuição gaussiana inteira centrada no $0$, porém isso 
acarreta em um problema na implementação, $-1$ módulo $Q$ é $Q-1$, o que estouraria o limite de corretude da decifração. Portanto,
basta implementar uma função que lide com esse problema modular:

\begin{minted}{python3}
    def sym_mod(a, q):
        a = ZZ(a) % q
        if 2*a > q:
            return a - q
        return ZZ(a)
\end{minted}

Neste ponto se torna necessário a introduzir a operações de decomposição. Tome o vetor $g^\top = (1, 2, \dots, 2^{\ell-1})$ e a matriz definida por 
$G = g^\top \otimes I_2$.  

\begin{lemma}[lema 2.3 \cite{lw23I}]
Dado um inteiro $q$, seja $\ell = \lceil \log q \rceil$, $\mathbf{g}^\top = (1, 2, \dots, 2^{\ell - 1})$ e uma base fixa $\mathbb{Z}_q$ de $\{ \mathbf{b}_1, \dots, \mathbf{b}_n \}$ de $\mathcal{O}_K / q \mathcal{O}_K$. Então, existe uma função aleatória e eficientemente computável
\[
\mathbf{g}^{-1} : \mathcal{O}_K / q \mathcal{O}_K \rightarrow \mathcal{O}_K^\ell
\]
tal que a saída da função, $\mathbf{x} \leftarrow \mathbf{g}^{-1}(a)$, sempre satisfaz $\langle \mathbf{g}, \mathbf{x} \rangle = a \bmod q$.

Mais especificamente, se $a = a_1 \mathbf{b}_1 + \dots + a_n \mathbf{b}_n$ onde $a_i \in \mathbb{Z}_q$ e $\mathbf{x}_i \leftarrow \mathbf{g}^{-1}(a_i)$ (onde a função $\mathbf{g}^{-1}(\cdot)$ é definida no Lema~2.1), então:
\[
\mathbf{x} = \mathbf{x}_1 \mathbf{b}_1 + \dots + \mathbf{x}_n \mathbf{b}_n
\]
e cada vetor $\mathbf{x}_i \in \mathbb{Z}_q^\ell$ é sub-Gaussiano com parâmetro $O(1)$.
\end{lemma}

Basicamente, se $x \in \mcR_Q$ então $g^{-1}(x)$ representa uma decomposição desse polinômio na base 2, na implementação feita
é bem simples:
\begin{minted}{python3}
    def inv_g_ZZ(x, B, Q):
        x = sym_mod(ZZ(x), Q)
        l = ceil(log(Q,B))
        return vector(x.digits(base=B, padto=l))

    def inv_g_poly(x, B, Q, n):
        l = ceil(log(Q,B))
        result = vector(Zx, [0]*l)
        pow_x = Zx(1)
        for i in range(euler_phi(n)):
            result += pow_x * inv_g_ZZ(x[i], B, Q)
            pow_x *= Zx(x)
        return result
\end{minted} 

Perceba que é possível definir a mesma função para $G$, $G^{-1}$. A mesma se baseia na aplicação da anterior nas devidas linhas 
tal que $\langle \mathbf{G}, \mathbf{G^{-1}(x)} \rangle = x$, sua implementação está no repositório.

\subsection{Esquemas}
Abaixo estão presentes os parâmetros utilizados nos esquemas:

\begin{itemize}[itemsep=0pt, parsep=0pt]
    \item[-] $\lambda$: o parâmetro de segurança
    \item[-] $\mathcal{R}$: o anel ciclotômico $\frac{\mathbb{Z}[x]}{<\Phi_{m}(x)>}$
    \item[-] $Q$: o módulo inteiro onde as cifras operam
    \item[-] $\mathcal{R}_{Q}$: o anel quociente $\mathcal{R}/Q\mathcal{R}$
    \item[-] $\mathcal{D_{\sigma}}$: Distribuição gaussiana discreta de ruído sobre $\mathcal{R}$ com desvio padrão $\sigma$.
    \item[-] $l$ = $\log_t(Q)$  
\end{itemize}

\subsubsection{Esquema RLWE}

Considere também como parâmetros da cifra como o módulo do texto puro o inteiro $t$, o módulo inteiro do criptograma $Q$,
o desvio padrão $\sigma$ da distribuição gaussiana e o inteiro $m$ representando o m-ésimo polinômio ciclotômico.   

\begin{itemize}[itemsep=0pt, parsep=0pt]
    \item[-] \textbf{KeyGen}($1^{\lambda}$): Amostre uma chave secreta $s \leftarrow \mathcal{R}_Q$
    \item[-] \textbf{Enc}(sk, $\mu \in \mathcal{R}_t$): Amostre um elemeto uniforme do anel $a \leftarrow \mathcal{R}_q$ e
um erro $e \leftarrow \mathcal{D_{\sigma}}$. Retorne um criptograma definido por 
    $$
    c := (a, sa + \left\lfloor \frac{Q}{t} \right\rceil \mu + e)
    $$
    \item[-] \textbf{Dec}(c, sk): O algoritmo retorna um elemento $\mu \in \mathcal{R}_t$ definido por:
    $$
        \mu = \left\lfloor t \left\langle (1,-s),c \right\rangle/Q \right\rceil  \pmod{t}  
    $$
\end{itemize}

O ruído de um criptograma $c$ que ecriptma $\mu$ sobre a chave secreta $s$ pode ser definido por 
$$Err_\mu(c) = \left\langle (-s,1), c \right\rangle- \left\lfloor \frac{Q}{t} \right\rceil \mu$$

\subsubsection{Esquema RGSW}

\begin{itemize}[itemsep=0pt, parsep=0pt]
    \item[-] \textbf{KeyGen}($1^{\lambda}$): Amostre uma chave secreta $s \leftarrow \mathcal{R}_Q$.
    \item[-] \textbf{Enc}(sk, $\mu \in \mathcal{R}$): Amostre um vetor uniformemente $\mathbf{a} \leftarrow \mathcal{R}_Q^{2\ell}$ e um vetor de ruído $e \leftarrow D_{\sigma}^{2\ell}$. Retorne um 
    criptograma definido por $C := \begin{pmatrix} s \mathbf{a}^\top + \mathbf{e}^\top \\ \mathbf{a}^\top \end{pmatrix} + \mu \mathbf{G} \in R_Q^{2 \times 2\ell}$
    \item[-] \textbf{Dec}(c, sk): O algortimo retorna um elemento $\mu \in \mathcal{R}/2\mathcal{R}$:
    $$ 
    \mu = \left\lfloor \left\langle (1,-s),_{(2\ell -1)}c \right\rangle/Q \right\rceil  \pmod{2}  
    $$
    
\end{itemize}

O ruído de um criptograma $C$ que encripta a mensagem $\mu$ sobre a chave secreta $sk = (1, -s)^T$ pode ser
definido por $Err_\mu(C) = e^T = sk^T \cdot C - \mu \cdot sk^T \cdot G$ 

\subsection{Operações}

\begin{itemize}
    \item[-] \textbf{Soma Homomórfica} $C_1 \boxplus C_2 $: Recebe dois criptogramas RGSW $C_1, C_2$ cifrados sobre a mesma chave e retorna $C_1 \boxplus C_2 := C_1 + C_2$. 
    O novo criptograma obtido cifra a soma das mensagens ($\mu_1, \mu_2$):
    $$
    C_1 + C_2 = \begin{pmatrix} s (\mathbf{a_1}^\top + \mathbf{a_2}^\top) + \mathbf{E}^\top \\ \mathbf{a_1}^\top + \mathbf{a_2}^\top \end{pmatrix} + (\mu_1 + \mu_2) \mathbf{G}
    $$
    \item[-] \textbf{Multiplicação Homomórfica} $C_1 \boxdot C_2$: Recebe dois criptogramas RGSW $C_1, C_2$ cifrados sobre a mesma chave e retorna $C_1 \boxdot C_2 := C_1 \mathbf{G^{-1}}(C_2)$. 
    O novo criptograma obtido cifra a multiplicação das mensagens ($\mu_1, \mu_2$): 
    $$
    C_1 \mathbf{G^{-1}}(C_2) = \begin{pmatrix} s \mathbf{a_1}^\top + \mathbf{e_1}^\top \\ \mathbf{a_1}^\top \end{pmatrix} \mathbf{G^{-1}}(C_2)  + (\mu_1) \begin{pmatrix} s \mathbf{a_2}^\top + \mathbf{e_2}^\top \\ \mathbf{a_2}^\top \end{pmatrix} + \mu_1 \mu_2 \mathbf{G}
    $$
    $$
        = \begin{pmatrix} s (\mathbf{a_1}^\top \mathbf{G^{-1}}(C_2) + \mu_1 \mathbf{a_2}^\top) + \mathbf{e_1}^\top \mathbf{G^{-1}}(C_2) + \mu_1 \mathbf{e_2}^\top \\ \mathbf{a_1}^\top + \mu_1 \mathbf{a_2}^\top \end{pmatrix}  + \mu_1 \mu_2 \mathbf{G}
    $$
    \item[-] \textbf{Produto Externo} $C_1 \boxtimes c_2 $: Recebe um criptogramas RGSW e um RLWE $C_1, C_2$ respectivamente cifrados sobre a mesma chave e retorna $C_1 \boxtimes C_2 := C_1 \mathbf{g^{-1}}(c_2)$. 
    O novo criptograma obtido cifra a multiplicação das mensagens ($\mu_1, \mu_2$) pelo processo análogo ao anterior, suprimido para conscisão.
\end{itemize}

Para checar a implementação dos esquemas e cada uma das operações descritas acesse o \href{https://github.com/gustavoesteche/ic-bootstraping/tree/main/src_sage/dual}{github}.