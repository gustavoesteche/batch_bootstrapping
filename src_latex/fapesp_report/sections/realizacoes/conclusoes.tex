\subsection{Complexidades}
Para a memória, é trivial que um inteiro com tamanho máximo $Q$ pode ser representado por $\log Q$ bits, disto, segue que um  polinômio de grau $N$ com seus coeficientes em $\mathbb{Z}_Q$ é representado por $O(N \log Q)$ bits. Na implementação realizada fica claro que a complexidade de memória do \emph{framework} é $O(r N \log^2 Q)$ que provém das chaves de bootstrapping, em que cada criptograma tem $O(N \log^2Q)$ bits armazenando $r$ mensagens, valores idênticos ao desenvolvido anteriormente, por exemplo em \cite{Guimaraes2023Amortized}. 

Para complexidade temporal, a parte relevante para este trabalho é a do produto externo definido pelo trabalho analisado. A complexidade do \textit{produto externo padrão} envolve, primeiramente, a decomposição de dois polinômios. Em seguida, executa-se a multiplicação de um vetor $(1 \times 2\ell)$ por uma matriz $(2\ell \times 2)$, cujos elementos são polinômios com coeficientes de até $N \log Q$ bits. Essa etapa requer $4\ell$ multiplicações polinomiais e $4\ell - 2$ somas polinomiais, resultando na complexidade final $O(N \log N \log^2 Q)$.
 
No \textbf{traço homomórfico}, além de um produto externo, são realizadas $\log r$ chamadas de \textit{key-switch} em que cada uma tem duas aplicações de automorfismo. Cada key-switch demanda uma decomposição polinomial, $2\ell$ multiplicações polinomiais e $2\ell-2$ somas polinomiais. Agregando isto, por cada produto interno no framework proposto temos $[(2\ell-2) \log r + 8\ell - 2]$ somas polinomiais, $[2\ell \log r + 8\ell]$ multiplicações polinomiais, $(2 \log r)$ automorfismos e $(\log r + 2)$ decomposições. Ao utilizarmos as complexidades mais favoráveis obtemos $O(N \log N \log r \log^2 Q )$, substituindo pelos parâmetros propostos $\tilde{O}(\lambda \log ^3 \lambda \log r)$ por produto externo de $r$ mensages, resultando em uma complexidade amortizada $\tilde{O}(\log ^4 \lambda) \cong \tilde{O}(1)$ em contraste de $O(\lambda \log^3 \lambda) \cong \tilde{O}(\lambda)$ obtido pelo TFHE apresentado em \cite{Guimaraes2023Amortized}.

\subsection{Comentário final}
A implementação atual ainda não é capaz de explorar plenamente todo o potencial teórico do \textit{framework} proposto. Há diversas otimizações possíveis, como o uso de NTTs mais otimizadas, a substituição do módulo $Q$ por um primo adequado, decomposições mais eficientes, uso de CRT, pré-computação dos automorfismos na base (com \textit{trade-off} de memória), entre outras técnicas possíveis descritas em artigos \cite{lw23II, lyubashevsky2013}. Apesar dessas limitações, a presente implementação serve como guia e demonstra resultados promissores, especialmente pelo bom comportamento observado no ruído. Com a aplicação das otimizações mencionadas, será possível quantificar com precisão as constantes associadas ao produto externo proposto. No entanto, na implementacão atual, o novo método ainda é mais lento, na prática, quando comparado a outros produtos externos amortizados do estado da arte, como em \cite{Guimaraes2023Amortized}. Assim, uma implementação otimizada é indispensável para garantir uma comparação justa e fidedigna com tais abordagens. 
